---
title: "【Go】古いコードからの卒業を支えるMCP"
emoji: "✨"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["go", "golang", "mcp", "llm", "ai"]
published: false
---

## はじめに
### 本記事の要旨
Claude Code などの LLM を活用したコーディングエージェント（以下、エージェントと呼びます）の利用が急速に進んでいます。私もエージェントを機会があるごとに利用していますが、**エージェントが学習データの古さに引っ張られて、Goの新しい言語機能や標準パッケージを使用してくれないことがある**という課題に歯痒い思いをしていました（そして結局私が自分で書き直す羽目になります）。

以下のスライドでも指摘されているように、エージェントには最新の言語仕様に関する知識をインプットしてあげることが必要です。
@[speakerdeck](5397d93f454742c8897a55688cd43491)

また、静的解析からのLint&Formatが市民権を得ているGoのような言語の場合は、古い言語機能や標準パッケージの利用を検出して警告することも有用な方法です（以下のスライドは直近でイイね！と感じた参考資料です）。
@[speakerdeck](79f6f21580ca4e768fbb131d0352280e)

本記事では前者のアプローチを採用し、**エージェントが自律的にGoの最新情報を取得可能にするMCPサーバーの作成方法**について紹介します。私の趣味でGoを選んでいますが、この手法は他の言語でも同様に適用可能です。

私はMCPサーバーの実装をGo言語で行いました。実装の大半をエージェントに任せてみたところ、予想通りやや古いGoの書き方で実装されましたが、作成したMCPを使って知識をアップデートし、リファクタリングを実行したところ、狙い通りに新しい標準パッケージ等を使用してくれるようになりました✨

作成したMCPサーバーのコードはこちらです。
https://github.com/tenkoh/recent-go-mcp

:::message
上記MCPサーバーで一番重要な"Goの最新情報を保持しているデータ"はGoのリリースノートから情報を抽出し作成したものですが、その内容を現時点で私が精査できていません。これから精査する予定ですので、その点をご承知おきください。
:::

### 本記事の対象読者
- エージェントが最新の言語機能やパッケージを使ってくれないことを解消したい人
- MCPサーバーの作成に興味がある人

### 本記事で扱わないこと
- 各LLMモデル、エージェントの使いこなし
- MCPサーバーの基本

### 結び
次の章から本題に入って参ります。以下の順序で説明します。

- 最新情報インプットになぜMCPサーバーを選んだのか
- MCPサーバーの実装手順
- 作成したMCPサーバーを利用する

## 最新情報インプットになぜMCPサーバーを選んだのか
私たちがエージェントに最新情報をインプットする方法は、いくつか考えられます。例えば、`CLAUDE.md`や`copilot-instructions.md`のような各エージェントが参照するルールファイルに最新情報を記載しておく方法は、シンプルで効果的なアプローチの一つです。

しかし、Goの場合、異なるバージョンの利用が`go.mod`によって非常に気軽に行えることもあり、プロジェクトごとに利用するGoのバージョンが異なることは日常的です。**例えば、Go1.22を使用しているプロジェクトにとって、Go1.23〜1.24（執筆時点最新）の情報は逆にノイズとなってしまうため、プロジェクトのGoバージョンに応じた適切な情報フィルタリングが必要と考えました。**

そこで私は、MCPサーバーを作成することにしました。以下の順序で動作することを目指します：

1. エージェントが`go.mod`ファイルまたは`go version`コマンドから、プロジェクトが使用するGoのバージョンを確認する
2. MCPサーバーにGoのバージョンを入力として送信し、そのバージョンまでに実施されたGoの言語機能および標準パッケージのアップデート情報を取得する
    * コンテキストウィンドウの節約のため、パッケージ名によるフィルタリングも可能にしておく

このアプローチにより、エージェントは必要な最新情報のみを取得でき、不要なノイズを排除することができます。

## MCPサーバーの実装手順
それでは、具体的な実装を進めていきます。
今回の実装では、エージェント（Claude Code with Claude Sonnet 4）を活用して進めていきます。おそらく、**現在私たちが直面している「エージェントが新しい機能を使ってくれない」という課題により、最初は古い機能を使って実装されることになるでしょう。しかし、完成したMCPサーバーを使ってリファクタリングすれば、動作確認も兼ねることができて一石二鳥です** ✌️

### アップデート情報の保持
私たちは、Goの各マイナーバージョンのアップデート情報をリポジトリ内に保持することにしました。具体的には、公式のリリースノートを解析し、情報を構造化してJSON形式で保存します。このJSONファイルは、最終的に Go 1.16から導入された`embed`パッケージを使用して実行ファイルに埋め込み、シングルバイナリファイルでの配布を可能にします。

リリースノートからの情報抽出作業も、エージェントに任せることにしました。また、今後のGoバージョンアップにも対応できるよう、情報抽出のためのプロンプトも整備しておく必要があります。このプロンプト作成もエージェントに依頼し、「抽出手順を計画し、再現性の高いプロンプトを作成してください」と指示しました。（エージェントの能力の高さに、私の存在意義を考えさせられます…）

作成したプロンプトは以下のリポジトリで公開しています：
https://github.com/tenkoh/recent-go-mcp/blob/main/make_changelog_prompt.md

このプロンプトを使用してGo1.24のリリースノートを解析し、結果を確認したところ、期待通りの出力が得られました。

その後、段階的に作業を進め、現時点でGo1.13までの情報を保管しました。

:::message
私たちは、どの時点からのアップデート情報を準備しておくべきか悩みましたが、各種LLM・エージェントは少なくとも`go mod init`などのモジュール関連の処理は理解しているようです。そのため、Goモジュールが導入されたGo1.11以降の世界線に入るようです。この観察から、ひとまずGo1.13程度からで十分だろうという仮説を立てました。
:::

### サーバーの実装
次に、MCPサーバー本体の実装に移ります。

Go言語用のMCP公式SDKは現時点で存在しないため、私たちは`github.com/mark3labs/mcp-go`パッケージを使用して実装することにしました。

エージェントにMCPサーバーを実装してもらう際は、Model Context Protocolの公式チュートリアルに従って進めることで、効率的に開発を進めることができました。具体的には、MCPの仕様が記述された`llms-full.txt`と各SDKのドキュメントをエージェントに読み込ませ、私たちが実現したいMCPサーバーの仕様を指示していきます。

https://modelcontextprotocol.io/tutorials/building-mcp-with-llms

:::message
余談ですが、上記チュートリアルでエージェントに読み込ませている`llms-full.txt`は相当なボリュームがあります。これにより、私たちは「このくらいの量のコンテキストをエージェントに渡しても大丈夫なんだ」という貴重な学びを得ることができました。この経験から、複数バージョンのアップデート情報をまとめて渡しても同等程度以下の量で収まると判断できました。
:::

私たちのMCPサーバーは以下の仕様で実装することにしました：

- MCPサーバーの機能提供方法として`Resource`と`Tool`のどちらを採用するか検討しましたが、サーバー側で情報をフィルタリングして返却する処理が必要なため、`Tool`として実装することにしました
- 引数1（必須）: `1.21`のような形式で、どのバージョンまでのアップデート情報を取得したいかを指定
- 引数2（任意）: `os`のようなパッケージ名を指定し、そのパッケージについてのアップデート情報のみを取得。バージョンとのAND条件でフィルタリングを行う
- 返却する情報は、LLMが理解しやすい形式を採用（この部分はエージェントに委ねました）
  - 結果として、エージェントから以下のような構造化された形式が提案され、採用しました：

```json
{
  "version": "1.XX",
  "release_date": "YYYY-MM-DDTHH:MM:SSZ",
  "summary": "One-sentence compelling summary highlighting revolutionary/major features",
  "changes": [
    {
      "category": "language|runtime|toolchain|platform",
      "description": "Specific technical description with concrete details",
      "impact": "new|enhancement|performance|breaking|deprecation"
    }
  ],
  "packages": {
    "package/name": [
      {
        "function": "FunctionName (optional)",
        "description": "Detailed function/feature description",
        "impact": "new|enhancement|performance|breaking|deprecation",
        "example": "Practical code example (optional)"
      }
    ]
  }
}
```

方針が決まったところで、私たちはエージェントに実装を進めてもらいました。実装は以下の環境で行いました：

- Claude Code（LLM: Claude Sonnet 4）
- Go 1.24

**驚くことに、基本的な実装は非常にスムーズに進みました**。ただし、コードの保守性・拡張性の観点で改善の余地があったため、いくつかの修正を要しました：

- 初期実装では、`main`関数に処理がベタ書きされ、バージョンごとに分けてあるJSONファイルをグローバル変数としてembedして読み込むなど、メンテナンス性の低いコードが生成されました。また、テストコードも存在しませんでした。
- SOLID原則やテスタビリティの観点から改善を依頼したところ、コードの品質は大幅に向上しました。ただし、この時点では**Goの便利な新しい標準パッケージなどは使用されていませんでした**。

このように課題はあったものの、私たちが必要としていた機能は予定通り実装することができました！

## 作成したMCPサーバーを利用する
MCPホストによって登録方法は異なりますが、基本的には`go run github.com/tenkoh/recent-go-mcp@latest`を実行するように登録することで、このMCPサーバーを利用できます。

MCPサーバーの実装を進める過程で、私は一つの興味深いアイデアを思いつきました。**せっかく作成したこのMCPサーバーを使って、MCPサーバーのコード自体も最新のGoの機能に追従させてみてはどうでしょうか？**

そこで私は、`recent-go-mcpツールを使って、現在のコードを最新のGoの機能・標準パッケージによって改善できる点を探し、適切に修正せよ`とエージェントに依頼してみました。

https://github.com/tenkoh/recent-go-mcp/commit/3b57412392beb4869bbaa4728237cc43220e2cfc

**予想以上の修正が行われましたが、驚くべき速さでコードが現代的な実装に置き換えられていきました！** （カスタムエラー型の導入や`context`パッケージの活用など、Goのベストプラクティスに基づく修正も同時に行われました。これは恐らく、エージェントが保持している一般的なGoのプログラミング知識が活かされたものと考えられます。）

この結果から、私たちの目標であった「エージェントに新しいGoの言語機能や標準パッケージを使わせる」ということが、十分に達成できそうだと確信が持てました。

## おわりに
私は週末の家事育児の合間を縫ってClaude Codeに指示を出し、このMCPサーバーを作成しました。結果として、今後も自分で継続的に使っていきたいと思えるMCPサーバーが誕生しました🐣。

冒頭でも述べましたが、最も重要なバージョンアップ情報をまとめたデータの精査が現時点では完了していません。この作業は私自身が丁寧にコツコツと進めていく予定です。もし読者の皆様からフィードバックを頂ければ、大変ありがたく存じます。
